---
phase: 05-recording-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/recordingStorage.ts
  - src/types/recording.ts
  - src/hooks/useRecordingHistory.ts
autonomous: true
---

<objective>
Create IndexedDB storage layer for persisting recordings with metadata.

Purpose: Enable recordings to survive page refreshes and be accessed later for viewing/deletion.
Output: Working storage utilities and hook for managing recording persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/recording.ts
@src/hooks/useRecording.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexedDB storage utilities</name>
  <files>src/utils/recordingStorage.ts</files>
  <action>
Create IndexedDB storage utilities for recordings:

1. Database config: DB name "formcheck-recordings", version 1, store name "recordings"
2. Schema: { id (auto-increment key), blob, timestamp, duration, fileSize }
3. Functions to implement:
   - `openDatabase(): Promise<IDBDatabase>` - opens/creates the DB
   - `saveRecording(recording: SavedRecording): Promise<number>` - saves recording, returns id
   - `getAllRecordings(): Promise<StoredRecording[]>` - returns all recordings sorted by timestamp desc
   - `getRecording(id: number): Promise<StoredRecording | null>` - gets single recording
   - `deleteRecording(id: number): Promise<void>` - deletes recording by id
   - `getStorageStats(): Promise<{ count: number; totalSize: number }>` - returns count and total bytes

Use native IndexedDB API (no idb wrapper needed for this simple case). Handle errors gracefully with console.error and rejected promises.
  </action>
  <verify>TypeScript compiles without errors: npm run build</verify>
  <done>All storage functions exported and type-safe</done>
</task>

<task type="auto">
  <name>Task 2: Extend Recording type for persistence</name>
  <files>src/types/recording.ts</files>
  <action>
Extend the recording types to support persistence:

1. Keep existing `Recording` interface unchanged (used during active recording)
2. Add `StoredRecording` interface:
   ```typescript
   interface StoredRecording {
     id: number;
     blob: Blob;
     timestamp: Date;
     duration: number;
     fileSize: number;
   }
   ```
3. Add `SavedRecording` type (omits id for saving new recordings):
   ```typescript
   type SavedRecording = Omit<StoredRecording, 'id'>;
   ```

Export all types from the file.
  </action>
  <verify>TypeScript compiles: npm run build</verify>
  <done>StoredRecording and SavedRecording types exported</done>
</task>

<task type="auto">
  <name>Task 3: Create useRecordingHistory hook</name>
  <files>src/hooks/useRecordingHistory.ts</files>
  <action>
Create a React hook for managing recording history:

```typescript
interface UseRecordingHistoryReturn {
  recordings: StoredRecording[];
  isLoading: boolean;
  error: string | null;
  saveRecording: (recording: Recording) => Promise<number>;
  deleteRecording: (id: number) => Promise<void>;
  refreshRecordings: () => Promise<void>;
  storageStats: { count: number; totalSize: number };
}
```

Implementation:
1. Load recordings on mount using useEffect
2. `saveRecording`: Converts `Recording` to `SavedRecording` (adds fileSize from blob.size), saves to IndexedDB, refreshes list
3. `deleteRecording`: Deletes from IndexedDB, refreshes list
4. `refreshRecordings`: Reloads all recordings from IndexedDB
5. Track loading state and errors
6. Calculate storage stats after each operation

Use useCallback for stable function references. Handle errors by setting error state (don't throw).
  </action>
  <verify>TypeScript compiles: npm run build</verify>
  <done>Hook exports useRecordingHistory with all CRUD operations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] All three files exist with correct exports
- [ ] Types are consistent across files
</verification>

<success_criteria>
- All tasks completed
- IndexedDB operations work (will be tested in next plan)
- No TypeScript errors
- Clean separation: storage utils → types → hook
</success_criteria>

<output>
After completion, create `.planning/phases/05-recording-history/05-01-SUMMARY.md`
</output>
