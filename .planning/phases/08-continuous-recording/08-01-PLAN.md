---
phase: 08-continuous-recording
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/recording.ts, src/utils/chunkStorage.ts]
autonomous: true
---

<objective>
Create chunk storage infrastructure for continuous recording.

Purpose: Enable progressive saving of video chunks to IndexedDB to survive page refresh and avoid memory exhaustion.
Output: RecordingChunk types and chunkStorage.ts utility with IndexedDB operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-continuous-recording/08-RESEARCH.md

# Existing patterns to follow:
@src/utils/recordingStorage.ts
@src/types/recording.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chunk types to recording.ts</name>
  <files>src/types/recording.ts</files>
  <action>
Add types for continuous recording chunks:

```typescript
/**
 * A chunk from continuous recording, stored progressively in IndexedDB.
 */
export interface RecordingChunk {
  id?: number;
  sessionId: string;
  chunkIndex: number;
  blob: Blob;
  timestamp: number;
  uploaded: boolean;
}

/**
 * Session metadata for continuous recording.
 */
export interface ContinuousSession {
  sessionId: string;
  startTime: number;
  endTime?: number;
  status: 'recording' | 'uploading' | 'complete' | 'failed';
  totalChunks: number;
  uploadedChunks: number;
}

export type ContinuousRecordingState = 'idle' | 'recording' | 'paused' | 'uploading';
```

Add these after the existing types. Do NOT modify existing types.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>RecordingChunk, ContinuousSession, and ContinuousRecordingState types exported</done>
</task>

<task type="auto">
  <name>Task 2: Create chunkStorage.ts utility</name>
  <files>src/utils/chunkStorage.ts</files>
  <action>
Create new file following the pattern from recordingStorage.ts.

Key differences:
- New database: 'formcheck-chunks' (separate from recordings)
- Two object stores: 'chunks' and 'sessions'
- Chunks indexed by sessionId and uploaded status
- Sessions indexed by status

Functions to implement:
1. `openChunkDatabase()` - Opens/creates the chunks database
2. `saveChunk(chunk)` - Saves a chunk, returns id
3. `getChunksBySession(sessionId)` - Get all chunks for a session
4. `getPendingChunks()` - Get chunks where uploaded=false
5. `markChunkUploaded(id)` - Set uploaded=true
6. `deleteChunksBySession(sessionId)` - Delete all chunks for session
7. `saveSession(session)` - Save/update session metadata
8. `getSession(sessionId)` - Get session by id
9. `getActiveSessions()` - Get sessions not complete/failed
10. `updateSessionStatus(sessionId, status)` - Update session status

Use DB_VERSION = 1, create indexes for:
- chunks: sessionId, uploaded
- sessions: status

Follow the exact promise wrapper pattern from recordingStorage.ts.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>chunkStorage.ts created with all functions, TypeScript compiles</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npx tsc --noEmit passes
- [ ] All types exported from recording.ts
- [ ] All functions exported from chunkStorage.ts
- [ ] No lint errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Types and storage functions ready for useContinuousRecording hook
</success_criteria>

<output>
After completion, create `.planning/phases/08-continuous-recording/08-01-SUMMARY.md`
</output>
